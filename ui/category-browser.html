<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Category Browser - INS TEMPO</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .search-container {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: #2196f3;
        }

        .autocomplete-items {
            position: absolute;
            top: 100%;
            left: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .autocomplete-item:hover,
        .autocomplete-item.active {
            background: #e3f2fd;
        }

        .type-indicator {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-header {
            background: #e3f2fd;
            color: #1976d2;
        }

        .type-dataset {
            background: #fff3e0;
            color: #f57c00;
        }

        .toc-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .level-1 h1,
        .level-2 h2,
        .level-3 h3 {
            margin: 20px 0 10px 0;
            padding: 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .level-1 h1 {
            font-size: 20px;
            color: #1976d2;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .level-2 h2 {
            font-size: 16px;
            color: #455a64;
            background: #f5f5f5;
            border-left: 3px solid #90a4ae;
            margin-left: 20px;
        }

        .level-3 h3 {
            font-size: 14px;
            color: #666;
            background: #fafafa;
            border-left: 2px solid #ccc;
            margin-left: 40px;
        }

        .code {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            margin-right: 8px;
            color: #f57c00;
        }

        ul.datasets {
            list-style: none;
            margin: 10px 0 20px 20px;
            padding: 0;
        }

        ul.datasets li {
            padding: 8px 12px;
            margin: 4px 0;
            background: #fafafa;
            border-left: 3px solid #90caf9;
            border-radius: 3px;
            transition: all 0.2s;
        }

        ul.datasets li:hover {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        ul.datasets a {
            text-decoration: none;
            color: inherit;
        }

        ul.datasets a.ccode {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #1976d2;
            margin-right: 8px;
        }

        ul.datasets a.cname {
            color: #555;
        }

        ul.datasets a.cname:hover {
            color: #1976d2;
        }

        ul.datasets code {
            font-size: 11px;
            color: #666;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        ul.datasets .size-M.is-much,
        ul.datasets .size-G {
            background: #ffebee;
            color: #c62828;
            font-weight: 600;
        }

        ul.datasets .warning-badge {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 8px;
            background: #fff3e0;
            color: #f57c00;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        ul.categories {
            list-style: none;
            padding: 0;
        }

        ul.categories > li {
            margin-bottom: 10px;
        }

        .stats-bar {
            background: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 13px;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .stats-bar span {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .stats-bar strong {
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            padding: 20px;
            background: #ffebee;
            color: #c62828;
            border-radius: 4px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>INS TEMPO - Category Browser</h1>
            <div class="nav-links">
                <a href="category-browser.html" class="nav-link active">Categories</a>
                <a href="index.html" class="nav-link">Dimensions</a>
            </div>
        </div>

        <div class="stats-bar" id="stats-bar" style="display: none;">
            <span><strong id="category-count">0</strong> categories</span>
            <span><strong id="dataset-count">0</strong> datasets</span>
            <span>Total: <strong id="total-size">0</strong> MB</span>
            <span><strong id="large-files-count">0</strong> files > 5MB</span>
        </div>

        <div id="toc-container" class="toc-container">
            <div class="loading">Loading categories...</div>
        </div>
    </div>

    <script>
        // CSV Parser function
        function parseCsv(csv) {
            const lines = [];
            let currentLine = '';
            let inQuotes = false;

            // First, split into lines respecting quotes
            for (let i = 0; i < csv.length; i++) {
                const char = csv[i];
                const nextChar = csv[i + 1];

                if (char === '"') {
                    inQuotes = !inQuotes;
                    currentLine += char;
                } else if ((char === '\n' || (char === '\r' && nextChar === '\n')) && !inQuotes) {
                    if (currentLine.trim()) {
                        lines.push(currentLine);
                    }
                    currentLine = '';
                    if (char === '\r') i++; // skip \n in \r\n
                } else {
                    currentLine += char;
                }
            }
            if (currentLine.trim()) lines.push(currentLine);

            if (lines.length === 0) return [];

            const headers = parseCSVLine(lines[0]);

            return lines.slice(1)
                .filter(line => line.trim())
                .map(line => {
                    const values = parseCSVLine(line);
                    return headers.reduce((obj, header, index) => {
                        obj[header] = values[index] || '';
                        return obj;
                    }, {});
                });
        }

        // Parse a single CSV line
        function parseCSVLine(line) {
            const values = [];
            let currentValue = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"' && nextChar === '"' && inQuotes) {
                    // Escaped quote
                    currentValue += '"';
                    i++; // Skip next quote
                } else if (char === '"') {
                    // Toggle quote mode
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    // Field separator
                    values.push(currentValue.trim());
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }
            values.push(currentValue.trim());

            return values;
        }

        // Build hierarchy from categories
        function buildHierarchy(categories) {
            const hierarchy = [];
            const lookup = {};
            const level0Codes = new Set();

            // First, identify level 0 codes (root categories)
            categories.forEach(category => {
                if (category.level === '0') {
                    level0Codes.add(category.code);
                }
            });

            // Create lookup for all non-level-0 categories
            categories.forEach(category => {
                if (category.level === '0') return;

                lookup[category.code] = {
                    ...category,
                    children: [],
                    datasets: []
                };

                // If parent is level 0, this is a top-level category
                if (level0Codes.has(category.parentCode)) {
                    hierarchy.push(lookup[category.code]);
                }
            });

            // Build parent-child relationships for non-root categories
            categories.forEach(category => {
                if (category.level === '0') return;
                if (level0Codes.has(category.parentCode)) return; // Skip top-level

                const parent = lookup[category.parentCode];
                if (parent) {
                    parent.children.push(lookup[category.code]);
                }
            });

            return { hierarchy, lookup };
        }

        // Add datasets to their categories
        function addDatasetsToCategories(datasets, datasetMetadata, lookup) {
            datasets.forEach(dataset => {
                const parentCategory = lookup[dataset.directAncestor];
                if (parentCategory) {
                    // Enrich dataset with metadata
                    const metadata = datasetMetadata[dataset.fileName];
                    parentCategory.datasets.push({
                        ...dataset,
                        metadata
                    });
                }
            });
        }

        // Convert human-readable size to MB
        function humanSizeToMB(human) {
            if (!human || typeof human !== 'string') return 0;

            const size = parseFloat(human.replace(/[^0-9.]/g, ''));
            if (isNaN(size)) return 0;

            const unit = human.slice(-1);

            switch (unit) {
                case 'B': return size / (1024 * 1024);
                case 'K': return size / 1024;
                case 'M': return size;
                case 'G': return size * 1024;
                default: return 0;
            }
        }

        // Format file size with color coding
        function formatFileSize(human) {
            const sizeMB = humanSizeToMB(human);
            const size = parseFloat(human.replace(/[^0-9.]/g, ''));
            const unit = human.slice(-1);

            let cssClass = 'size-' + unit;
            if ((unit === 'M' && size >= 4.2) || unit === 'G') {
                cssClass += ' is-much';
            } else if (unit === 'M' || unit === 'K' || (unit === 'B' && size >= 500)) {
                cssClass += ' not-much';
            }

            return `<span class="${cssClass}">${human}</span>`;
        }

        // Generate HTML for TOC
        function generateTocHtml(node) {
            let html = '';

            if (node.level) {
                const levelClass = `level-${node.level}`;
                html += `<div class="${levelClass}">
                    <h${node.level} id="x-${escapeHtml(node.code)}">
                        <span class="code">${escapeHtml(node.code)}</span>
                        ${escapeHtml(node.name)}
                    </h${node.level}>
                </div>\n`;
            }

            // Add datasets
            if (node.datasets && node.datasets.length > 0) {
                html += '<ul class="datasets">\n';
                node.datasets.sort((a, b) => a.fileName.localeCompare(b.fileName));

                node.datasets.forEach(dataset => {
                    const sizeMB = humanSizeToMB(dataset.filesize);
                    const warning = sizeMB > 5 ? '<span class="warning-badge">⚠ Large</span>' : '';

                    html += `  <li>
                        <a class="ccode" href="dataset-profile.html?id=${escapeHtml(dataset.fileName)}">${escapeHtml(dataset.fileName)}</a>
                        <a class="cname" href="dataset-profile.html?id=${escapeHtml(dataset.fileName)}">${escapeHtml(dataset.matrixName)}</a>
                        <code>${formatFileSize(dataset.filesize)}</code>
                        ${warning}
                    </li>\n`;
                });
                html += '</ul>\n';
            }

            // Process children
            if (node.children && node.children.length > 0) {
                node.children.sort((a, b) => a.code.localeCompare(b.code));

                html += '<ul class="categories">\n';
                node.children.forEach(child => {
                    html += '<li class="lx-' + node.level + '">\n';
                    html += generateTocHtml(child);
                    html += '</li>\n';
                });
                html += '</ul>\n';
            }

            return html;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Build search index
        function buildSearchIndex() {
            const searchItems = [];

            // Index headers
            document.querySelectorAll('[id^="x-"]').forEach(header => {
                const code = header.querySelector('.code')?.textContent || '';
                const name = header.textContent.replace(code, '').trim();
                searchItems.push({
                    type: 'header',
                    code,
                    name,
                    element: header,
                    text: `${code} ${name}`,
                    id: header.id
                });
            });

            // Index dataset links
            document.querySelectorAll('.datasets li').forEach(item => {
                const code = item.querySelector('.ccode')?.textContent || '';
                const name = item.querySelector('.cname')?.textContent || '';
                const link = item.querySelector('a')?.href;
                searchItems.push({
                    type: 'dataset',
                    code,
                    name,
                    link,
                    text: `${code} ${name}`
                });
            });

            return searchItems;
        }

        // Highlight match in text
        function highlightMatch(text, query) {
            if (!query) return escapeHtml(text);
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return escapeHtml(text).replace(regex, '<strong>$1</strong>');
        }

        // Escape regex special characters
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Add search functionality
        function addSearch() {
            const searchContainer = document.createElement('div');
            searchContainer.className = 'search-container';
            searchContainer.innerHTML = `
                <input type="text" class="search-input" placeholder="Caută în capitole și seturi de date...">
                <div class="autocomplete-items" style="display: none;"></div>
            `;

            const tocContainer = document.getElementById('toc-container');
            tocContainer.parentNode.insertBefore(searchContainer, tocContainer);

            const searchInput = searchContainer.querySelector('.search-input');
            const autocompleteList = searchContainer.querySelector('.autocomplete-items');
            const searchIndex = buildSearchIndex();

            function handleSearch() {
                const query = searchInput.value.toLowerCase();
                if (!query) {
                    autocompleteList.style.display = 'none';
                    return;
                }

                const matches = searchIndex.filter(item =>
                    item.text.toLowerCase().includes(query)
                ).slice(0, 30);

                if (matches.length === 0) {
                    autocompleteList.style.display = 'none';
                    return;
                }

                autocompleteList.innerHTML = matches.map(item => `
                    <div class="autocomplete-item" data-type="${item.type}" ${
                        item.type === 'header' ? `data-id="${item.id}"` :
                        item.type === 'dataset' ? `data-link="${item.link}"` : ''
                    }>
                        <span class="type-indicator type-${item.type}">${item.type}</span>
                        ${highlightMatch(item.code, query)} - ${highlightMatch(item.name, query)}
                    </div>
                `).join('');

                autocompleteList.style.display = 'block';
            }

            autocompleteList.addEventListener('click', (e) => {
                const item = e.target.closest('.autocomplete-item');
                if (!item) return;

                if (item.dataset.type === 'header') {
                    const element = document.getElementById(item.dataset.id);
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    element.style.backgroundColor = '#fff3cd';
                    setTimeout(() => element.style.backgroundColor = '', 2000);
                } else if (item.dataset.type === 'dataset') {
                    window.location.href = item.dataset.link;
                }

                searchInput.value = '';
                autocompleteList.style.display = 'none';
            });

            searchInput.addEventListener('input', handleSearch);

            document.addEventListener('click', (e) => {
                if (!searchContainer.contains(e.target)) {
                    autocompleteList.style.display = 'none';
                }
            });

            // Keyboard navigation
            searchInput.addEventListener('keydown', (e) => {
                const items = autocompleteList.getElementsByClassName('autocomplete-item');
                const activeItem = document.querySelector('.autocomplete-item.active');
                let index = Array.from(items).indexOf(activeItem);

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        if (index < items.length - 1) index++;
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (index > 0) index--;
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (activeItem) activeItem.click();
                        return;
                    default:
                        return;
                }

                Array.from(items).forEach(item => item.classList.remove('active'));
                if (items[index]) {
                    items[index].classList.add('active');
                    items[index].scrollIntoView({ block: 'nearest' });
                }
            });
        }

        // Calculate and display statistics
        function updateStats(categories, datasets) {
            const totalSizeMB = datasets.reduce((sum, d) => sum + humanSizeToMB(d.filesize), 0);
            const largeFiles = datasets.filter(d => humanSizeToMB(d.filesize) > 5).length;

            document.getElementById('category-count').textContent = categories.filter(c => c.level !== '0').length;
            document.getElementById('dataset-count').textContent = datasets.length;
            document.getElementById('total-size').textContent = totalSizeMB.toFixed(2);
            document.getElementById('large-files-count').textContent = largeFiles;
            document.getElementById('stats-bar').style.display = 'flex';
        }

        // Main initialization
        async function initializeTableOfContents() {
            try {
                // Load CSV files and metadata
                const [categoriesResponse, datasetsResponse, metadataResponse] = await Promise.all([
                    fetch('../data/ui-helpers/x-categories.csv'),
                    fetch('../data/ui-helpers/x-datasets-size.csv'),
                    fetch('data/dataset-metadata.json')
                ]);

                if (!categoriesResponse.ok || !datasetsResponse.ok) {
                    throw new Error('Failed to load CSV files');
                }

                const [categoriesCsv, datasetsCsv] = await Promise.all([
                    categoriesResponse.text(),
                    datasetsResponse.text()
                ]);

                // Parse CSV data
                const categories = parseCsv(categoriesCsv);
                const datasets = parseCsv(datasetsCsv);

                // Load metadata if available
                let datasetMetadata = {};
                if (metadataResponse.ok) {
                    const metadataJson = await metadataResponse.json();
                    metadataJson.metadata.forEach(item => {
                        datasetMetadata[item.matrixCode] = item;
                    });
                }

                // Build hierarchy
                const { hierarchy, lookup } = buildHierarchy(categories);
                hierarchy.sort((a, b) => a.code.localeCompare(b.code));

                // Add datasets to categories
                addDatasetsToCategories(datasets, datasetMetadata, lookup);

                // Generate HTML
                let tocHtml = '<div class="table-of-contents">\n';
                hierarchy.forEach(node => {
                    tocHtml += generateTocHtml(node);
                });
                tocHtml += '</div>';

                document.getElementById('toc-container').innerHTML = tocHtml;

                // Add search
                addSearch();

                // Update statistics
                updateStats(categories, datasets);

            } catch (error) {
                console.error('Error loading table of contents:', error);
                document.getElementById('toc-container').innerHTML = `
                    <div class="error">
                        Error loading table of contents: ${error.message}
                        <br>Please check that the CSV files are available and properly formatted.
                    </div>
                `;
            }
        }

        // Initialize when ready
        document.addEventListener('DOMContentLoaded', initializeTableOfContents);
    </script>
</body>
</html>
